// 添加请求拦截器
axios.interceptors.request.use(function(config) {
    // 在发送请求之前做些什么
    return config;
}, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
});
// 添加响应拦截器
axios.interceptors.response.use(function(response) {
    // 对响应数据做点什么
	var data=response.data;
	if (data['errCode'] && data.errCode === 'sign.code100001') {
		alert(data.message);
		top.location.href='/index.html';
		return;
	}
    return data;
}, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
});

window.FMG={
	log:function(a){
		var l=document.querySelector('#logs');
		if(l) {
			var m=JSON.stringify(a),p=document.createElement('p');
			console.log(a),p.innerHTML=m,l.appendChild(p);
		}
	}
};
FMG.Wallet={
	__at:{}, __contracts:{}, Authorized:false,VERSION:'20210406',
	web3:function(){
		return new Web3(window.ethereum)
	},
	eth:function(){
		return FMG.Wallet.web3().eth
	},
	auth:function(f){
		if(FMG.Wallet.Authorized) {
			f(window.ethereum.selectedAddress);
			return;
		}
		window.ethereum.enable().then(function(accounts){
			FMG.Wallet.Authorized=true,f(accounts[0]);
		}).catch(function(er){
			FMG.log(['fmg.auth', er]);
			alert(er.message)
		})
	},
	walletAddress:function() {
		return window.ethereum.selectedAddress
	},
	at:function(){
		// m=fmg.balanceOf  类型.方法名，合约地址默认为 0
		// m=fmg.0.balanceOf  类型.合约地址.方法名
		var args=[],m=arguments[0],ms=m.split('.'),A=ms[0],B=ms[1],I=0;
		if(ms.length>2)I=ms[1],B=ms[2];
		for(var i=1;i<arguments.length;i++) args.push(arguments[i]);
		FMG.Wallet.auth(function(account){
			var X=[A,I].join('.');
			if (FMG.Wallet.__at&&FMG.Wallet.__at[X]) {
				var c=FMG.Wallet.__at[X][B];
				c.apply(c,args);
			} else {
				axios.get(['/static/json/abi_v2_',A,'.json?v=', FMG.Wallet.VERSION].join('')).then(function(conf){
					var abi=conf['abi'],contract=conf['contract'][I];
					FMG.log(['FMG.at',contract]);
					FMG.Wallet.__at[X]=FMG.Wallet.eth().contract(abi).at(contract);
					var c=FMG.Wallet.__at[X][B];
					c.apply(c,args);
				})
			}
		})
	},
	
};

window.NFT={};
NFT.Wallet={
	__at:{}, __contracts:{}, Authorized:false,VERSION:'20210406',
	web3:function(){
		return new Web3(window.ethereum)
	},
	eth:function(){
		return NFT.Wallet.web3().eth
	},
	auth:function(f){
		if(NFT.Wallet.Authorized) {
			f(window.ethereum.selectedAddress);
			return;
		}
		window.ethereum.enable().then(function(accounts){
			NFT.Wallet.Authorized=true,f(accounts[0]);
		}).catch(function(er){
			alert(er.message)
		})
	},
	walletAddress:function() {
		return window.ethereum.selectedAddress
	},
	at:function(){
		var args=[],m=arguments[0],ms=m.split('.'),A=ms[0],B=ms[1];
		var contract = arguments[1]
		for(var i=2;i<arguments.length;i++) args.push(arguments[i]);
		NFT.Wallet.auth(function(account){
			var X=[A].join('.');
			if (NFT.Wallet.__at&&NFT.Wallet.__at[X]) {
				var c=NFT.Wallet.__at[X][B];
				c.apply(c,args);
			} else {
				axios.get(['/static/json/abi_v2_',A,'.json?v=', NFT.Wallet.VERSION].join('')).then(function(conf){
					var abi=conf['abi']
					NFT.Wallet.__at[X]=NFT.Wallet.eth().contract(abi).at(contract);
					var c=NFT.Wallet.__at[X][B];
					c.apply(c,args);
				})
			}
		})
	},

};